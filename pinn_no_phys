""" PINN implementation of opinion model """

import tensorflow as tf
from tensorflow import keras

tf.keras.backend.set_floatx('float32')

from pinn      import PhysicsInformedNN
from eq_no_phys import test
import matplotlib.pyplot as plt
import numpy as np

#lr = keras.optimizers.schedules.ExponentialDecay(1e-3, 1000, 0.9)
lr = 1e-3
layers  = [2] + 2*[64] + [1]
PINN = PhysicsInformedNN(layers,
                         dest='./', #saque el /odir porque no hacia falta 
                         activation='elu',
                         optimizer=keras.optimizers.Adam(lr),
                         restore=True)
PINN.model.summary()

model_show = True
sol_show = True


def u(X):
  sol = np.zeros(len(X))
  for i in range(len(X)):
    x = X[i,1]
    t = X[i,0]
    lower = t - 1
    uper = 1 - t
    sol[i] = np.where((x<lower) | (x>uper),0,1) * 1/(2-2*t)            
  return sol.reshape((len(X),1))


Lx = 2
Nx = 200
Nt = 500

t = np.linspace(0,100,Nt)
x = np.linspace(-1,1,Nx)

T,X = np.meshgrid(t,x)  
X = np.hstack((np.sort(T.flatten()[:,None],axis=0),X.flatten(order='F')[:,None])) #Ordeno el vector como (t,x)

Y =u(X) #[u(t_0,x_0),u(t_1,x_1),...]

lambda_data = 1
lambda_phys = 0

alpha   = 0.0
tot_eps = 300
eq_params = [Lx/Nx]
eq_params = [np.float32(p) for p in eq_params] #eq_params es el diferencial de x que paso para calcular la integral

PINN.train(X, Y, test,
           epochs=tot_eps,
           eq_params=eq_params,
           batch_size=Nt*Nx,
           lambda_data=lambda_data,   # Punto donde se enfuerza L_bc
           lambda_phys=lambda_phys,   # Punto donde se enfuerza L_pde
           rnd_order_training=False,  # No arma batches al hacer
           alpha=alpha,
           verbose=True,
           timer=False)




fields = (PINN.model(X)[0]).numpy()


if sol_show == True:
    fig = plt.figure(figsize = (10,10))
    ax = plt.axes(projection='3d')
    ax.scatter3D(X[:,0].flatten(), X[:,1].flatten(), u(X).flatten())
    ax.view_init(10,90)
    plt.show()

if model_show == True:   
    fig = plt.figure(figsize = (10,10))
    plt.title('Model')
    ax = plt.axes(projection='3d')
    ax.scatter3D(X[:,0].flatten(), X[:,1].flatten(), fields)
    ax.view_init(10,90)
    plt.show()





