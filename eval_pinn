""" PINN implementation of opinion model """

import tensorflow as tf
from tensorflow import keras

tf.keras.backend.set_floatx('float64')

from pinn      import PhysicsInformedNN
from equations import opinion_model
import matplotlib.pyplot as plt
import numpy as np

#lr = keras.optimizers.schedules.ExponentialDecay(1e-3, 1000, 0.9)
lr = 1e-3
layers  = [2] + 6*[128] + [1]
PINN = PhysicsInformedNN(layers,
                         dest='./', #saque el /odir porque no hacia falta 
                         activation='elu',
                         optimizer=keras.optimizers.Adam(lr),
                         restore=True)


def u(X):
  sol = np.zeros(len(X))
  for i in range(len(X)):
    x = X[i,1]
    t = X[i,0]
    lower = t - 1
    uper = 1 - t
    sol[i] = np.where((x<lower) | (x>uper),0,1) * 1/(2-2*t)        
  return sol.reshape((len(X),1))

sol_3D_show = False
model_3D_show = False
model_show = True # Solucion de la red en todo el espacio 
sol_show = True # Solucion real en todo el espacio
loss_val = True # Funcion de perdida + Validation
val = True # Validation sola
cond_in = True # Condicion inicial
x_0 = True # Sigo el punto x=0 para todo tiempo
rand_point = True #Miro un punto (X=0) a algun tiempo aleatorio 


Lx = 2
Nx = 200
Nt = 100

t = np.linspace(0,0.8,Nt)
x = np.linspace(-1,1,Nx)

T,X = np.meshgrid(t,x)
X = np.hstack((np.sort(T.flatten()[:,None],axis=0),X.flatten(order='F')[:,None])) #Ordeno el vector como (t,x)
Y = u(X) #[u(t_0,x_0),u(t_1,x_1),...]

lambda_data = np.zeros(Nt*Nx) #[1,0,0,..]
lambda_data[:Nx] = 1
lambda_phys = np.ones(Nt*Nx)
lambda_phys[:Nx] = 0 #[0,1,1,..]
flags = np.repeat(np.arange(Nt),Nx)

alpha   = 0.0
tot_eps = 300
eq_params = [Lx/Nx]
eq_params = [np.float32(p) for p in eq_params] #eq_params es el diferencial de x que paso para calcular la integral


fields = PINN.model(X)[0]


#Veo la evolucion temporal del punto x = 0
x_eval = np.array([(tt,0) for tt in np.linspace(0,0.8)])
u_eval = u(x_eval)
fields_eval = PINN.model(x_eval)[0]

#Miro la solucion a t_fijo = t_0
t_fijo = 0.5
x_eval_1 = np.array([(t_fijo,tt) for tt in np.linspace(-1,1)])
u_eval_1 = u(x_eval_1)
fields_eval_1 = PINN.model(x_eval_1)[0]




if sol_3D_show == True:
    fig = plt.figure(figsize = (10,10))
    ax = plt.axes(projection='3d')
    ax.scatter3D(X[:,0].flatten(), X[:,1].flatten(), u(X).flatten())
    ax.view_init(10,90)

if model_3D_show == True:  
    fig = plt.figure(figsize = (10,10))
    plt.title('Model')
    ax = plt.axes(projection='3d')
    ax.scatter3D(X[:,0].flatten(), X[:,1].flatten(), fields)
    ax.view_init(10,90)

if sol_show == True:
    solution = np.reshape(Y,(Nt,Nx))    
    for _ in range(3):
      solution = np.rot90(solution)
    plt.figure(figsize=(5,5))
    plt.imshow(solution, cmap = 'hot',extent=[0,1,-1,1],aspect=0.4)
    cax = plt.axes([0.85, 0.1, 0.075, 0.8])
    plt.colorbar(cax=cax)
    
    

if model_show == True:   
    model = np.reshape(fields,(Nt,Nx))    
    for _ in range(3):
      model = np.rot90(model)
    plt.figure(figsize=(5,5))
    plt.imshow(model, cmap = 'hot',extent=[0,1,-1,1],aspect=0.4)
    cax = plt.axes([0.85, 0.1, 0.1, 0.8])
    plt.colorbar(cax=cax)
    
    

if loss_val == True:
  plt.figure()
  out = np.loadtxt('output.dat', unpack=True)
  out_1 = np.loadtxt('validation.dat', unpack=True)
  plt.semilogy(out[0], out[1], label='Loss function')
  plt.semilogy(out_1[0], out_1[1], label='Validation')
  props = dict(boxstyle='round', facecolor='blue', alpha=0.1)
  textstr = '\n'.join((
    rf'(Nt,Nx)= ({Nt},{Nx})' ,
    r'Layers = 3*64' ,
    rf'Learning Rate = {lr} (fijo)' ,
    rf'Epochs = {tot_eps}'))
  plt.text(1500, 0.55, textstr, fontsize=10,
        verticalalignment='top', bbox=props)
  plt.title('Training loss/Validation')
  plt.xlabel('Epochs')
  plt.ylabel('Loss')
  plt.legend()

if val == True:
    plt.figure()  
    out_1 = np.loadtxt('validation.dat', unpack=True)
    plt.semilogy(out_1[0], out_1[1], label='Validation')          
    plt.title('Validation')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    


if cond_in == True:
  plt.figure()
  plt.title('Condicion Inicial')
  plt.plot(X[:Nx,1],fields[:Nx],label = 'Red Neuronal')
  plt.plot(X[:Nx,1],u(X[:Nx]),label = 'Solucion Real')
  plt.xlabel('X')
  plt.ylabel('u(X)')
  plt.legend()


if x_0 == True:
  plt.figure()
  plt.title(f'Solucion a t = {t_fijo}')
  props = dict(boxstyle='round', facecolor='blue', alpha=0.1)
  plt.plot(x_eval_1[:,1],fields_eval_1,label = 'Red Neuronal')
  plt.plot(x_eval_1[:,1],u_eval_1,label = 'Solucion Real')  
  plt.text(-0.85, 0.8, rf'$t_{0} = {t_fijo}$', fontsize=10,verticalalignment='top', bbox=props)
  plt.xlabel('X')
  plt.ylabel('$u(x,t = t_{0})$')
  plt.legend()


if rand_point == True:
  plt.figure()
  plt.legend()
  plt.scatter(x_eval[:,0],fields_eval,label = 'NN')
  plt.scatter(x_eval[:,0],u_eval,label = 'Solucion')
  plt.xlabel('t')
  plt.ylabel('u(x = 0,t)')
  plt.legend()


plt.show()